# 函数式编程和声明式编程

## 前言

首先要明白，函数式编程和声明式编程并不是对立的概念，**函数式编程属于声明式编程范式**：这种范式会**描述一系列的操作**，但并不会**暴露它们是如何实现的**或是**数据流如何传过它们**。

详见**声明式、命令式与面向对象编程.md**

## 什么是函数式编程

**函数式编程** （通常简称为 FP）是指通过复合**纯函数**来构建软件的过程，它避免了**共享的状态（share state）**、**易变的数据(mutable data)**、以及**副作用(side-effects)**。函数式编程是**声明式**而不是**命令式**，并且应用程序状态通过纯函数流转。对比面向对象编程，后者的应用程序状态通常是共享并共用于对象方法。

函数式编程是一种**编程范式**意味着它是一种软件构建的思维方式，有着自己的理论基础和界定法则。其他编程范式的例子包括面向对象编程和过程式编程。

与命令式或面向对象代码相比，函数式代码倾向于更简洁、更可预测以及更易于测试 —— 但是如果你对它以及与它相关的常见模式不熟悉，读函数式代码会让你觉得信息量太大，而且相关文献对于初学者来说往往难以理解。

最难的部分是记住那些以前不熟悉的词汇。在这些名词定义中蕴含了许多思想，只有理解了它们，才能够开始掌握函数式编程真正的意义：

- 纯函数（Pure functions）
- 函数复合（Function composition）
- 避免共享状态（Avoid shared state）
- 避免改变状态（Avoid mutating state）
- 避免副作用（Avoid side effects）

换句话说，如果想要了解函数式编程在实际中的意义，需要从理解那些核心概念开始。

### 纯函数

一个**纯函数**是这样的一个函数：

- 给它同样的输入，总是返回同样的结果，并且
- 没有副作用

常常这些情况会产生副作用。

- 改变一个全局的变量、属性或数据结构
- 改变一个函数参数的原始值
- 处理用户输入
- 抛出一个异常
- 屏幕打印或记录日志
- 查询 HTML 文档，浏览器的 Cookie 或访问数据库

举一个简单的例子

```
var counter = 0
function increment() {
    return ++counter;
}
复制代码
```

这个函数就是不纯的，它读取了外部的变量，可能会觉得这段代码没有什么问题，但是我们要知道这种依赖外部变量来进行的计算，计算结果很难预测，你也有可能在其他地方修改了 counter 的值，导致你 increment 出来的值不是你预期的。

对于纯函数有以下性质：

- 仅取决于提供的输入，而不依赖于任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态。
- 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数

纯函数有着许多对函数式编程而言非常重要的属性，包括**引用透明**（输出结果是一致的，可预测的，相同的输入会有相同的返回值，这个被称为**引用透明**。可以将一个函数调用替换成它的结果值，而不会对程序的运行造成影响）。

### 函数复合

函数复合是结合两个或多个函数，从而产生一个新函数或进行某些计算的过程。例如，复合操作 `f·g`（点号意思是对两者执行复合运算）在 JavaScript 中相当于执行 `f(g(x))`。理解函数复合是理解软件如何用函数式编程模型来构建的很重要的一步。

### 共享状态

**共享状态** 的意思是任意变量、对象或者内存空间存在于共享作用域下，或者作为对象的属性在各个作用域之间被传递。共享作用域包括全局作用域和闭包作用域。通常，在面向对象编程中，对象以添加属性到其他对象上的方式在作用域之间共享。

想象你有一个 user 对象需要保存。你的 `saveUser()` 函数向服务器 API 发起一个请求。此时，用户改变了他们的头像，通过 `updateAvatar()` 并触发了另一次 `saveUser()` 请求。在保存动作执行后，服务器返回一个更新的 user 对象，客户端要将这个对象替换内存中的对象，以保持与服务器同步。

不幸地是，第二次请求有可能比第一次请求更早返回，所以当第一次请求（现在已经过时了）返回时，新的头像又从内存中丢失了，被替换回旧的头像。这是一个同步竞争的例子，是一个非常常见的共享状态 bug。

共享状态的另一个常见问题是改变函数调用次序可能导致一连串的错误，因为函数操作共享数据是依时序的：

```
//使用共享数据，函数调用的次序会改变函数调用的结果
const x = {
  val: 2
};

const x1 = () => x.val += 1;

const x2 = () => x.val *= 2;

x1();
x2();

console.log(x.val); // 6

//下面的例子与上面的相同，除了……
const y = {
  val: 2
};

const y1 = () => y.val += 1;

const y2 = () => y.val *= 2;

// ...函数的调用次序颠倒了一下...
y2();
y1();

// ... 这改变了结果值:
console.log(y.val); // 5
```

如果你避免共享状态，函数的调用时序不同就不会改变函数的调用结果。使用纯函数，给定同样的输入，你将总是能得到同样的输出。这使得函数调用完全独立于其他函数调用，可以从根本上简化变更和重构。改变函数内容，或者改变函数调用的时序不会波及和破坏程序的其他部分。

```
const x = {
  val: 2
};

const x1 = x => Object.assign({}, x, { val: x.val + 1});

const x2 = x => Object.assign({}, x, { val: x.val * 2});

console.log(x1(x2(x)).val); // 5


const y = {
  val: 2
};

//由于它对于外部变量没有依赖,
//我们不需要不同的函数来操作不同的变量

//这里故意留白


//由于函数没有操作可变数据，你可以调用这些函数任意次，用各种次序
//都不会改变之后调用函数的结果值。
x2(y);
x1(y);

console.log(x1(x2(y)).val); // 5
```

在上面的例子里，我们使用了 `Object.assign()` 并传入一个空的 object 作为第一个参数来拷贝 x 的属性，以防止 x 在函数内部被改变。在这个例子里，它等价由于重新创建一个对象，而这是一种 JavaScript 里的通用模式， 用来拷贝已存在状态而不是使用引用，从而避免像我们第一个例子里产生的问题。

如果仔细看例子里的 `console.log()` 语句，你会发现我前面已经提到过的概念：函数复合。回顾一下，函数复合看起来像是这样： `f(g(x))`。在这个例子里，我们的 `f()` 和 `g()` 是 `x1()` 和 `x2()`，所以复合是 `x1·x2`。

**当然，如果你改变复合的顺序，输出将改变。操作的顺序仍然很重要。**`f(g(x))` 并不总是等价于 `g(f(x))`，但是，**有一件事情发生了改变，那就是函数外部的变量不会被修改** —— 原本函数修改外部变量是一个大问题。要是函数不纯，我们如果不了解函数使用或操作的每个变量的完整历史，就不可能完全理解它做了什么。

移除函数时序依赖，你就完全消除了一大类潜在的 bug。

### 不可变性

一个**不可变的（immutable）**对象是指一个对象不会在它创建之后被改变。对应地，一个**可变的(mutable)**对象是指任何在创建之后可以被改变的对象。

不可变性是函数式编程的一个核心概念，因为没有它，你的程序中的数据流是有损的。状态历史被抛弃而奇怪的 bug 可能会在你的软件中产生

在 JavaScript 中，很重要的一点是**不要混淆了 `const` 和不变性**。`const` 创建一个变量绑定，让该变量不能再次被赋值。`const` 并不创建不可变对象。你虽然不能改变绑定到这个变量名上的对象，但你仍然可以改变它的属性，这意味着 `const` 的变量仍然是可变的，而不是不可变的。

不可变对象完全不能被改变。你可以通过深度冻结对象来创造一个真正的不可变的值。JavaScript 提供了一个方法，能够浅冻结一个对象：

```
const a = Object.freeze({
  foo: 'Hello',
  bar: 'world',
  baz: '!'
});

a.foo = 'Goodbye';
// Error: Cannot assign to read only property 'foo' of object Object
```

然而冻结的对象只是表面一层不可变，例如，深层的属性还是可以被改变：

```
const a = Object.freeze({
  foo: { greeting: 'Hello' },
  bar: 'world',
  baz: '!'
});

a.foo.greeting = 'Goodbye';

console.log(`${ a.foo.greeting }, ${ a.bar }${a.baz}`);
```

如你所见，被冻结的 object 的顶层基本属性不能被改变，但是如果有一个属性本身也是 object（包括数组等），它依然可以被改变 —— 因此甚至被冻结的对象也不是不可变的，除非你遍历整个对象树并冻结每一个对象属性。

在许多函数式编程语言中，有特殊的不可变数据结构，被称为 **trie 数据结构**(trie 的发音为 tree)，这一结构有效地深冻结 —— 意味任何属性无论它的对象层级如何都不能被改变。

当一个对象被拷贝给一个操作符时，tries 使用**结构共享**来共用不可变对象的引用内存地址，这减少内存占用，而且能够显著地改善一些类型的操作的性能。

### 副作用（Side Effects）

副作用是指除了函数返回值以外，任何在函数调用之外观察到的应用程序状态改变。副作用包括：

- 改变了任何外部变量或对象属性（例如，全局变量，或者一个在父级函数作用域链上的变量）
- 写日志
- 在屏幕输出
- 写文件
- 发网络请求
- 触发任何外部进程
- 调用另一个有副作用的函数

在函数式编程中，副作用被尽可能避免，这使得程序的作用更容易理解，也使得程序更容易被测试。

现在需要做的是要从软件中隔离副作用行为。如果让副作用与程序逻辑分离，软件将会变得更易于扩展、重构、调试、测试和维护。

这也是为什么大部分前端框架鼓励我们分开管理状态和组件渲染，采用松耦合的模型。

### 通过高阶函数提升可重用性

函数式编程倾向于复用一组通用的函数功能来处理数据。面向对象编程倾向于把方法和数据集中到对象上。那些被集中的方法只能用来操作设计好的数据类型，通常是那些包含在特定对象实例上的数据。

在函数式编程里，对任何类型的数据一视同仁。同样的 `map()` 操作可以 map 对象、字符串、数字或任何别的类型，因为它接受一个函数参数，来适当地操作给定类型。函数式编程通过使用**高阶函数**来实现这一技巧。

在 JavaScript 里，**函数是一等公民**，JavaScript 允许使用者将函数作为数据 —— 可以将它们赋值给变量、作为参数传递给其他函数、将它们作为返回值返回，等等……

**高阶函数**指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值。高阶函数经常用于：

- 抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads，等等……
- 创建可以泛用于**各种数据类型**的功能
- 部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。
- 接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。

## 结论

函数式编程偏好：

- 使用纯函数而不是使用共享状态和副作用
- 让可变数据成为不可变的
- 用函数复合替代命令控制流
- 使用高阶函数来操作许多数据类型，创建通用、可复用功能取代只是操作集中的数据的方法。
- 使用声明式而不是命令式代码（关注做什么，而不是如何做）
- 使用表达式替代语句
- 使用容器与高阶函数替代多态