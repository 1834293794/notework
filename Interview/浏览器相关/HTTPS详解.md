# HTTPS详解

## 前言


​													![img](https://pic2.zhimg.com/80/v2-10efce49f484837df7c304c6570aeec9_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-bdeb151822932f73e724b6cf27425bf2_720w.jpg)





![img](https://pic4.zhimg.com/80/v2-1c5163717af4472622bf367a73dfa11f_720w.jpg)







## 什么是HTTP协议？

HTTP协议全称Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于TCP/IP四层模型当中的应用层。

![img](https://pic2.zhimg.com/80/v2-9ba73cb74c5122a63b761dafc6f2b535_720w.jpg)



HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。

![img](https://pic2.zhimg.com/80/v2-673b31f4fcac9f3a0cc68f49047c1cc5_720w.jpg)

## HTTP协议的缺点

这一切看起来很美好，但是HTTP协议有一个致命的缺点：**不够安全**。

HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢？让我们打一个比方：

小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。



![img](https://pic1.zhimg.com/80/v2-5d6f3dd19432efca1239da14a03db72c_720w.jpg)



但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做**中间人攻击**。

![img](https://pic3.zhimg.com/80/v2-962a13238153eb14a3a6db2def609456_720w.jpg)



![img](https://pic2.zhimg.com/80/v2-7799e14e9991e2e1a7e83483c6da5d75_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-2b7a98cdea1aa4a33731c8681760cdd2_720w.jpg)

如何进行加密呢？

## 对称加密的方法

小灰和小红可以事先约定一种**对称加密**方式（因为对称加密算法有很多种），并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。





![img](https://pic3.zhimg.com/80/v2-f44db3085c661cd5ed65ec091333e45e_720w.jpg)



![img](https://pic4.zhimg.com/80/v2-b9b8b0d8bd2faff248b085a34629a28f_720w.jpg)







这样做是不是就绝对安全了呢？并不是。



虽然我们在后续的通信中对明文进行了加密，但是**第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。**







![img](https://pic4.zhimg.com/80/v2-aff24615cc6e366c27166f222aafb2eb_720w.jpg)



这可怎么办呢？别担心，我们可以使用**非对称加密**，为密钥的传输做一层额外的保护。

## 对称加密和非对称加密搭配使用

非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。

在小灰和小红建立通信的时候，小红生成一个公钥和一个私钥，小红首先把自己的公钥Key1发给小灰：





![img](https://pic2.zhimg.com/80/v2-f3ab1daafe9daa179a15d447467c7aed_720w.jpg)



收到小红的公钥以后，小灰自己生成一个用于**对称加密**的密钥Key2，并且用刚才接收的公钥Key1对Key2进行加密（这里有点绕），发送给小红：



![img](https://pic2.zhimg.com/80/v2-d2daf8ba5615dc9d427a6fe3d20d1031_720w.jpg)



小红利用自己**非对称加密的私钥**，解开了公钥Key1的加密，获得了Key2的内容。**从此以后，两人就可以利用Key2进行对称加密的通信了。**



![img](https://pic4.zhimg.com/80/v2-d3ecc2fa78ccaed37c478b4055198ceb_720w.jpg)



在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。

![img](https://pic4.zhimg.com/80/v2-30c40e1ed1390d623cdb51725834e1fb_720w.jpg)





![img](https://pic1.zhimg.com/80/v2-b7b095e69390bb8d0dd3d50826d25444_720w.jpg)

是什么坏主意呢？中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。

![img](https://pic3.zhimg.com/80/v2-9a458296959c052b026560a5892368f2_720w.jpg)



小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。



这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。

![img](https://pic2.zhimg.com/80/v2-5123c1a68be44a178c6f6c1543dfc3f1_720w.jpg)



这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。

### 追问：既然如此，两个人都使用非对称加密的方法不就行了？

的确，只使用非对称加密是可以满足安全性要求的，但是由于**非对称加密的计算耗时高于对称加密的2-3个数量级（相同安全加密级别）**，所以才先使用非对称交换密钥，之后再使用对称加密通信。

![img](https://pic4.zhimg.com/80/v2-172b8cc90f0013804ac20e3f33da8967_720w.jpg)

是什么解决方案呢？难道再把公钥进行一次加密吗？这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。

这时候，我们有必要引入第三方，一个权威的证书颁发机构（CA）来解决。





## 最终解决方案：CA

### 1.什么是CA证书。

　**◇ 普通的介绍信**

　　想必大伙儿都听说过介绍信的例子吧？假设 A 公司的张三先生要到 B 公司去拜访，但是 B 公司的所有人都不认识他，他咋办捏？常用的办法是带公司开的一张介绍信，在信中说：兹有张三先生前往贵公司办理业务，请给予接洽......云云。然后在信上敲上A公司的公章。

　　张三先生到了 B 公司后，把介绍信递给 B 公司的前台李四小姐。李小姐一看介绍信上有 A 公司的公章，而且 A 公司是经常和 B 公司有业务往来的，这位李小姐就相信张先生不是歹人了。

这里，A公司就是CA证书

**◇ 引入中介机构的介绍信**

　　好，回到刚才的话题。如果和 B 公司有业务往来的公司很多，每个公司的公章都不同，那前台就要懂得分辨各种公章，非常滴麻烦。所以，有某个中介公司 C，发现了这个商机。C公司专门开设了一项“代理公章”的业务。

　　今后，A 公司的业务员去 B 公司，需要带2个介绍信：

　　介绍信1

　　含有 C 公司的公章及 A 公司的公章。并且特地注明：C 公司信任 A 公司。

　　介绍信2

　　仅含有 A 公司的公章，然后写上：兹有张三先生前往贵公司办理业务，请给予接洽......云云。

　　某些不开窍的同学会问了，这样不是增加麻烦了吗？有啥好处捏？

　　主要的好处在于，对于接待公司的前台，就不需要记住各个公司的公章分别是啥样子的；他/她只要记住中介公司 C 的公章即可。当他/她拿到两份介绍信之后，先对介绍信1的 C 公章，验明正身；确认无误之后，再比对介绍信1和介绍信2的两个 A 公章是否一致。如果是一样的，那就可以证明介绍信2是可以信任的了。



　　**◇ 什么是CA？**

　　CA是Certificate Authority的缩写，也叫“证书授权中心”。（专业的解释看“[这里](http://en.wikipedia.org/wiki/Certificate_authority)”）

　　它是负责管理和签发证书的第三方机构，就好比例子里面的中介——C 公司。一般来说，CA必须是所有行业和所有公众都信任的、认可的。因此它必须具有足够的权威性。就好比A、B两公司都必须信任C公司，才会找 C 公司作为公章的中介。

　**◇ 什么是CA证书？**

　　CA 证书，顾名思义，就是CA颁发的证书。

　　前面已经说了，人人都可以找工具制作证书。但是你一个小破孩制作出来的证书是没啥用处的。因为你不是权威的CA机关，你自己搞的证书不具有权威性。

　　这就好比上述的例子里，某个坏人自己刻了一个公章，盖到介绍信上。但是别人一看，不是受信任的中介公司的公章，就不予理睬。坏蛋的阴谋就不能得逞啦。

　　文本后续提及的证书，若无特殊说明，均指 CA 证书。

 

### 2.证书的签发过程：

1. 服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；

2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；

3. 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；

4. 客户端 C 向服务器 S 发出请求时，S 返回证书文件；

5. 客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；

6. 客户端然后验证证书相关的域名信息、有效时间等信息；

7. 客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。

**在这个过程注意几点：**

1. 申请证书不需要提供私钥，确保私钥永远只能服务器掌握；

2. 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；

3. 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书；

4. **证书=公钥+申请者与颁发者信息+签名；**

**到底什么是证书呢？证书包含如下信息：**

![img](https://pic4.zhimg.com/80/v2-d67c298621ff7b0993bf40fada27f573_720w.jpg)

### 3.https连接过程

- 客户端发送请求到服务器端
- 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
- 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
- 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
- 客户端使用共享密钥解密数据
- SSL加密建立……

### 4.总结整个过程：

1. 服务器向CA机构获取证书（假设这个证书伪造不了），当浏览器首次请求服务器的时候，服务器返回证书给浏览器。（证书包含：公钥+申请者与颁发者的相关信息+签名）

2. 浏览器得到证书后，开始验证证书的相关信息，证书有效（没过期等）。（验证过程，比较复杂，详见上文）。

3. 验证完证书后，如果证书有效，客户端是生成一个随机数，然后用证书中的公钥进行加密，加密后，发送给服务器，服务器用私钥进行解密，得到随机数。之后双方便开始用该随机数作为钥匙，对要传递的数据进行加密、解密。

 ### 5.追问

#### 1.这些措施能保证安全是建立在CA证书无法被伪造的前提上，那为什么CA证书无法被伪造呢？

制作证书需要使用对应CA机构的私钥，因此CA颁发的证书是无法被非法伪造的，第三方想伪造也因为不知道私钥而无从下手（CA私钥的泄露不在讨论范围内）

#### 2.既然CA证书不能被伪造，那直接撇开这张证书，第三方自己生成一对公钥和私钥，用自己的私钥做出一张假的CA证书发给客户端不就行了？

验证证书要用对应CA机构的公钥，这个公钥不是直接放在证书里的，那样当然毫无可信度。这个公钥必定是通过其他可信的方式提前获取得到的（比如由CA公布或者发放），需要说明的是，**各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥**。所以只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。这样用这个可信的公钥验证成功的证书就是可信的，证书里的信息也就是可信的。

第三方自己做的假的CA证书发给客户端后，客户端用 CA 的公钥解密签名数据，对比证书的信息摘要，肯定是不一致的，毕竟CA的公钥和第三方的公钥是不一样的。于是客户端就知道这张证书是假的，不予采信。

毕竟第三方总不能将假的CA证书发给客户端后，还特地把自己的公钥也发过去通知客户端用这个公钥去验证证书，这样客户端一下子就知道有诈。


​														![img](https://pic4.zhimg.com/80/v2-761d4917160cc15f06056f7043a84307_720w.jpg)







![img](https://pic4.zhimg.com/80/v2-abd130a15c5ba261a42f93add277948f_720w.jpg)











![img](https://pic1.zhimg.com/80/v2-0473074a3253131c0ad3ef4902cb2fb8_720w.jpg)





![img](https://pic3.zhimg.com/80/v2-0d5de173c1283fc80fa06e7a55140706_720w.jpg)







![img](https://pic4.zhimg.com/80/v2-6340df8970e6f498c68e629537cfa45b_720w.jpg)







![img](https://pic1.zhimg.com/80/v2-3db9b326b9d31745229a26a877a1308c_720w.jpg)







注：最新推出的TLS协议，是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的。

#### 3.那假如第三方得知了CA的公钥的情况下怎么办？

光知道CA的公钥也没用啊，第三方最多用这个公钥去解密CA证书里的加密了的服务端公钥，获取到服务端公钥，但之后因为它无法伪造CA证书，只能原封不动的把这张证书发给客户端。而它即便得到了服务端公钥也同样没什么用，客户端收到CA证书后，用CA公钥解密出服务端公钥，然后将自己生成的共享密钥用服务端公钥加密后然后发给服务端，第三方拦截到了这个信息，即使它手里有服务端的公钥，但解密是需要服务端的私钥的，它根本无法解密，自然也得不到共享密钥。最后服务端和客户端之间用共享密钥加密信息进行通信，第三方也是束手无策。

**归根结底上面提的对称加密和非对称加密搭配使用的方法会被破解就是因为第三方拦截了服务端的公钥，发给客户端的服务端公钥是自己伪造的。现在这个情况下，从第三方无法伪造CA证书用以发给客户端自己伪造的服务端公钥开始，它就注定没有办法了。**