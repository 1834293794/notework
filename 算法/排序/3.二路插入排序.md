# 二路插入排序

2路插入排序
2路插入是在折半插入的基础上进行改进。
折半插入在原先直接插入的基础上改进，通过折半查找，以较少的比较次数就找到了要插入的位置，但是在插入的过程中仍然没有减少移动次数，所以2路插入在此基础上改进，减少了移动次数，但是仍然并没有避免移动记录（如果要避免的话还是得改变存储结构）

那么如何减少的移动次数？？？
常规的一个数组{2, 7, 8,10,15 ,29,30, 40,50,66,70,80}，如果插入9，那么按照常规的折半查找后，需要移动记录9次，这是因为我们只能够在一个方向上插入。
因此我们设定一个辅助数组A，大小是原来数组相同的大小，将A[0]设为第一个原数组第一个数，通过设置first和final指向整个有序序列的最小值和最大值，即为序列的尾部和头部，并且将其设置位一个循环数组，这样就可以进行双端插入。此时原数组只需往左边移动3次。

之所以能减少移动次数的原因在于可以往2个方向移动记录，故称为2路插入。
A[0]的前面是个有序序列，后面也是有序序列，整个也是有序序列

具体操作思路：
1.将原数组第一个元素赋值给A[0],作为标志元素
2.按顺序依次插入剩下的原数组的元素

将带插入元素与第一个进行比较，偌大于A[0],则插入A[0]前面的有序序列，否则插入后面的有序序列
对前面的有序序列或后面的有序序列进行折半查找
查找到插入位置后进行记录的移动，分别往first方向前移和往final方向移动
插入记录
3.将排序好的A数组的数据从first到final，按次序赋值回原数组

```c
#include <stdio.h>
#include <stdlib.h>

void insert_sort(int *arr, int *temp, int n)
{
  int i, first, final, k;

  first = final = 0;
  temp[0] = arr[0];

  for (i = 1; i < n; i ++) {
    if (arr[i] < temp[first]) { // 待插入元素比最小的元素小
      first = (first - 1 + n) % n;
      temp[first] = arr[i];
    } else if (arr[i] > temp[final]) { // 待插入元素比最大元素大
      final = (final + 1 + n) % n;
      temp[final] = arr[i];
    } else { // 插入元素比最小大，比最大小
      k = (final + 1 + n) % n;
      while (temp[((k - 1) + n) % n] > arr[i]) {
        temp[(k + n) % n] =temp[(k - 1 + n) % n];
        k = (k - 1 + n) % n;
      }
      temp[(k + n) % n] = arr[i];
      final = (fianl + 1 + n) % n;
    }
  }

  // 将排序记录复制到原来的顺序表里
  for (k = 0; k < n; k ++) {
    arr[k] = temp[(first + k) % n];
  }
}

int main(void)
{
  int i, n, *arr, *temp;

  while (scanf("%d", &n) != EOF) {
    arr = (int *)malloc(sizeof(arr) * n);
    temp = (int *)malloc(sizeof(temp) * n);

    for (i = 0; i < n; i ++)
      scanf("%d", &arr[i]);

    insert_sort(arr, temp, n);

    for (i = 0; i < n; i ++)
      printf("%d ", arr[i]);
    printf("\n");
    free(arr);
    free(temp);
  }

  return 0;
}

```
